STATUS UPDATE: Fixes for fourier.py
===============================================
Last Updated: December 23, 2025

COMPLETED FIXES:
✅ Issue 1: get_option_expiration() - FIXED
✅ Issue 2: Expiration monitoring in backtest loop - FIXED  
✅ Issue 3: Signal detection improvements - FIXED
✅ Issue 4: Trend filtering functions - FIXED
✅ Issue 5: Dynamic position sizing function - FIXED
✅ Issue 6: Strike price validation - FIXED
✅ Issue 7: Look-ahead bias in backtest_signals - FIXED
✅ Issue 8: Commission/slippage parameters added - PARTIALLY FIXED

REMAINING WORK (3 items):
❌ Issue 8b: Implement commission/slippage logic in backtest loop
❌ Issue 9: Add advanced performance metrics
❌ Issue 10: Implement trade cooldown logic in backtest loop

---

## REMAINING ENHANCEMENTS TO IMPLEMENT

### Enhancement 1: Commission and Slippage Application in Backtest Loop

**STATUS:** Parameters added to function signature, but logic NOT implemented in loop

**Location:** `fourier.py`, inside `backtest_options_signals()` function
- Entry logic: Around line 1340-1370 (where positions are opened)
- Exit logic: Around line 1415-1520 (where positions are closed)

**What to do:**

1. **When OPENING positions** (around where `cost = entry_option_price * 100 * contracts_per_trade`):
```python
# FIND THIS SECTION (around line 1360):
cost = entry_option_price * 100 * contracts_per_trade

# REPLACE WITH:
# Apply slippage to entry (buy orders pay more)
entry_with_slippage = entry_option_price * (1 + slippage_percent / 100)

# Calculate cost with commission
cost = (entry_with_slippage * 100 * contracts_per_trade) + (commission_per_contract * contracts_per_trade)

# ALSO UPDATE the position object creation to use entry_with_slippage:
pos = OptionPosition(
    # ... existing fields ...
    entry_price=entry_with_slippage,  # NOT entry_option_price
    # ... rest of fields ...
)
```

2. **When CLOSING positions** (in all exit paths: stop-loss, take-profit, expiration, signal reversal):
```python
# FIND THIS PATTERN (appears 4 times around lines 1415, 1465, 1405, 1520):
capital += current_option_price * 100 * contracts_per_trade

# REPLACE WITH:
# Apply slippage to exit (sell orders receive less)
exit_with_slippage = current_option_price * (1 - slippage_percent / 100)

# Calculate revenue with commission
revenue = (exit_with_slippage * 100 * contracts_per_trade) - (commission_per_contract * contracts_per_trade)
capital += revenue

# ALSO UPDATE P&L calculations to use the actual slippage prices
```

**Why this matters:** Without commission/slippage, backtests are unrealistically optimistic. A strategy with 100 trades at $0.65/contract = $65 in commissions alone.

---

### Enhancement 2: Advanced Performance Metrics

**STATUS:** Not implemented

**Location:** Create new function in `fourier.py` around line 1650 (after `backtest_options_signals()`)

**What to do:**

Add this complete function:

```python
def calculate_advanced_metrics(closed_positions: List, initial_capital: float) -> Dict:
    """
    Calculate advanced performance metrics for options backtest.
    
    Parameters:
    -----------
    closed_positions : List[OptionPosition]
        List of closed positions from backtest
    initial_capital : float
        Starting capital
    
    Returns:
    --------
    Dict
        Dictionary of advanced metrics
    """
    import numpy as np
    
    if not closed_positions:
        return {
            'sharpe_ratio': 0.0,
            'max_drawdown_percent': 0.0,
            'max_drawdown_duration_days': 0,
            'profit_factor': 0.0,
            'avg_winner': 0.0,
            'avg_loser': 0.0,
            'largest_winner': 0.0,
            'largest_loser': 0.0,
            'consecutive_wins': 0,
            'consecutive_losses': 0,
            'expectancy': 0.0,
            'gross_profit': 0.0,
            'gross_loss': 0.0,
            'recovery_factor': 0.0,
            'avg_days_in_trade': 0.0
        }
    
    # Separate winners and losers
    winners = [p.pnl_dollar for p in closed_positions if p.pnl_dollar and p.pnl_dollar > 0]
    losers = [p.pnl_dollar for p in closed_positions if p.pnl_dollar and p.pnl_dollar <= 0]
    
    # Basic statistics
    avg_winner = np.mean(winners) if winners else 0.0
    avg_loser = np.mean(losers) if losers else 0.0
    largest_winner = max(winners) if winners else 0.0
    largest_loser = min(losers) if losers else 0.0
    
    # Profit factor
    gross_profit = sum(winners) if winners else 0.0
    gross_loss = abs(sum(losers)) if losers else 1.0
    profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
    
    # Build equity curve
    equity_curve = [initial_capital]
    for pos in sorted(closed_positions, key=lambda p: p.exit_date):
        if pos.pnl_dollar:
            equity_curve.append(equity_curve[-1] + pos.pnl_dollar)
    
    # Max drawdown
    peak = equity_curve[0]
    max_dd = 0.0
    max_dd_duration = 0
    dd_start_idx = 0
    current_dd_duration = 0
    
    for idx, val in enumerate(equity_curve):
        if val > peak:
            peak = val
            dd_start_idx = idx
            current_dd_duration = 0
        else:
            current_dd_duration = idx - dd_start_idx
            dd = (peak - val) / peak * 100 if peak > 0 else 0
            if dd > max_dd:
                max_dd = dd
                max_dd_duration = current_dd_duration
    
    # Consecutive wins/losses
    max_consec_wins = 0
    max_consec_losses = 0
    current_streak = 0
    last_was_win = None
    
    for pos in sorted(closed_positions, key=lambda p: p.exit_date):
        is_win = pos.pnl_dollar and pos.pnl_dollar > 0
        
        if is_win:
            if last_was_win:
                current_streak += 1
            else:
                current_streak = 1
            last_was_win = True
            max_consec_wins = max(max_consec_wins, current_streak)
        else:
            if last_was_win is False:
                current_streak += 1
            else:
                current_streak = 1
            last_was_win = False
            max_consec_losses = max(max_consec_losses, current_streak)
    
    # Expectancy
    win_rate = len(winners) / len(closed_positions)
    loss_rate = 1 - win_rate
    expectancy = (win_rate * avg_winner) + (loss_rate * avg_loser)
    
    # Sharpe ratio (annualized)
    returns = [p.pnl_dollar / initial_capital * 100 for p in closed_positions if p.pnl_dollar is not None]
    if returns and np.std(returns) > 0:
        avg_days_held = np.mean([p.days_held for p in closed_positions if p.days_held])
        trades_per_year = 252 / avg_days_held if avg_days_held > 0 else 0
        sharpe = (np.mean(returns) / np.std(returns)) * np.sqrt(trades_per_year)
    else:
        sharpe = 0.0
    
    # Recovery factor
    final_return = equity_curve[-1] - initial_capital
    recovery_factor = final_return / (initial_capital * max_dd / 100) if max_dd > 0 else 0.0
    
    # Average days in trade
    avg_days_in_trade = np.mean([p.days_held for p in closed_positions if p.days_held is not None])
    
    return {
        'sharpe_ratio': sharpe,
        'max_drawdown_percent': max_dd,
        'max_drawdown_duration_days': max_dd_duration,
        'profit_factor': profit_factor,
        'avg_winner': avg_winner,
        'avg_loser': avg_loser,
        'largest_winner': largest_winner,
        'largest_loser': largest_loser,
        'consecutive_wins': max_consec_wins,
        'consecutive_losses': max_consec_losses,
        'expectancy': expectancy,
        'gross_profit': gross_profit,
        'gross_loss': gross_loss,
        'recovery_factor': recovery_factor,
        'avg_days_in_trade': avg_days_in_trade
    }
```

Then **UPDATE** `backtest_options_signals()` return statement (around line 1600):

```python
# FIND (near end of function):
return OptionsBacktestResults(
    ticker=ticker,
    initial_capital=initial_capital,
    final_capital=capital,
    # ... existing fields ...
)

# ADD before the return:
advanced_metrics = calculate_advanced_metrics(closed_positions, initial_capital)

# THEN update the return to include metrics:
return OptionsBacktestResults(
    ticker=ticker,
    initial_capital=initial_capital,
    final_capital=capital,
    # ... existing fields ...
    advanced_metrics=advanced_metrics  # ADD THIS
)
```

**Also UPDATE** the `OptionsBacktestResults` dataclass (around line 1070) to include:
```python
@dataclass
class OptionsBacktestResults:
    # ... existing fields ...
    advanced_metrics: Optional[Dict] = None  # ADD THIS LINE
```

**Why this matters:** Professional backtests need Sharpe ratio, max drawdown, profit factor, etc. These are industry-standard metrics.

---

### Enhancement 3: Trade Cooldown Logic

**STATUS:** Parameter added (`min_days_between_trades`) but NOT used in loop

**Location:** `fourier.py`, `backtest_options_signals()` function around line 1340 (where new positions are opened)

**What to do:**

1. **Add tracking variable** at the start of the function (around line 1320):
```python
# FIND THIS SECTION (after initializing capital, open_positions, etc.):
capital = initial_capital
open_positions = []
closed_positions = []

# ADD THIS:
last_trade_date = None  # Track when we last opened a position
```

2. **Add cooldown check** BEFORE opening new positions (around line 1340):
```python
# FIND THIS SECTION (where we check if we can open new position):
if len(open_positions) >= max_positions:
    continue

# ADD AFTER THAT CHECK:
# Check cooldown period
if last_trade_date is not None:
    days_since_last = (current_date.date() - last_trade_date.date()).days
    if days_since_last < min_days_between_trades:
        if verbose:
            print(f"[{current_date.strftime('%Y-%m-%d')}] SKIPPED: Cooldown active "
                  f"({days_since_last}/{min_days_between_trades} days since last trade)")
        continue
```

3. **Update last_trade_date** AFTER successfully opening a position (around line 1370):
```python
# FIND THIS SECTION (after position is added to open_positions):
open_positions.append(pos)
capital -= cost

# ADD AFTER:
last_trade_date = current_date  # Update for cooldown tracking
```

**Why this matters:** Prevents overtrading on clustered signals. If you get 3 signals in a row, you don't want to open 3 positions immediately - spread them out.

---

## IMPLEMENTATION CHECKLIST

Use this checklist when implementing:

### Enhancement 1: Commission/Slippage
- [ ] Find entry cost calculation (line ~1360)
- [ ] Add slippage to entry_option_price
- [ ] Add commission to cost calculation
- [ ] Update OptionPosition to use slippage-adjusted price
- [ ] Find all 4 exit points (stop-loss, take-profit, expiration, reversal)
- [ ] Add slippage to exit price at each exit point
- [ ] Subtract commission from revenue at each exit point
- [ ] Update P&L calculations to reflect actual fills
- [ ] Test with commission=0.65, slippage=1.0

### Enhancement 2: Advanced Metrics
- [ ] Add calculate_advanced_metrics() function after backtest_options_signals()
- [ ] Update OptionsBacktestResults dataclass to include advanced_metrics field
- [ ] Call calculate_advanced_metrics() before return in backtest_options_signals()
- [ ] Add advanced_metrics to return statement
- [ ] Update print_options_backtest_summary() to display new metrics
- [ ] Test that metrics calculate correctly

### Enhancement 3: Trade Cooldown
- [ ] Add last_trade_date = None at function start
- [ ] Add cooldown check after max_positions check
- [ ] Update last_trade_date after opening position
- [ ] Test with min_days_between_trades=3
- [ ] Verify cooldown prevents rapid consecutive trades

---

## TESTING RECOMMENDATIONS

After implementing all 3 enhancements:

1. Run backtest with these settings to verify:
   - ticker: 'AAPL'
   - commission_per_contract: 0.65
   - slippage_percent: 1.0
   - min_days_between_trades: 3

2. Check output for:
   - Commission costs reducing returns
   - Slippage widening entry/exit prices
   - Cooldown preventing consecutive trades
   - Advanced metrics in summary

3. Compare with/without these features to see impact

---

## Original Issue Documentation Below
===============================================

## Critical Issues

### 1. **`get_option_expiration()` - Returns dates too far in the future**

**Location:** Lines 757-792

**Problem:** The function works correctly for *future* dates, but in historical replay, it's being called with past dates and returning expirations that may not have existed or are unrealistically far out (as seen in your logs where everything expired on 2025-12-26).

**Root Cause:** The function calculates the *next* Friday from the target date, but doesn't validate that this expiration actually existed in the options chain historically.

**Fix:**
```python
def get_option_expiration(current_date: datetime, days_to_expiry: int = 30, ticker: str = None) -> str:
    """
    Get the option expiration date approximately days_to_expiry days from current_date.
    """
    from datetime import timedelta, datetime as dt
    import pandas as pd

    # Convert numpy.datetime64 to Python datetime if needed
    if isinstance(current_date, pd.Timestamp) or hasattr(current_date, 'to_pydatetime'):
        current_date = current_date.to_pydatetime()
    elif not isinstance(current_date, dt):
        current_date = pd.Timestamp(current_date).to_pydatetime()

    # Remove timezone info if present (for consistent comparison)
    if current_date.tzinfo is not None:
        current_date = current_date.replace(tzinfo=None)

    # Calculate target expiration date
    target_expiration = current_date + timedelta(days=days_to_expiry)

    # Find the next Friday (options typically expire on Fridays)
    days_until_friday = (4 - target_expiration.weekday()) % 7
    if days_until_friday == 0 and target_expiration.weekday() != 4:
        days_until_friday = 7

    expiration = target_expiration + timedelta(days=days_until_friday)

    # Validate: expiration should be within a reasonable range
    # (not more than 2 years out for standard options)
    max_expiration = current_date + timedelta(days=730)
    if expiration > max_expiration:
        # Fall back to monthly expiration (3rd Friday of target month)
        expiration = get_third_friday(target_expiration.year, target_expiration.month)

    return expiration.strftime('%Y-%m-%d')


def get_third_friday(year: int, month: int) -> datetime:
    """Get the third Friday of a given month (standard monthly expiration)."""
    from datetime import datetime, timedelta
    
    # First day of the month
    first_day = datetime(year, month, 1)
    
    # Find first Friday
    days_until_friday = (4 - first_day.weekday()) % 7
    first_friday = first_day + timedelta(days=days_until_friday)
    
    # Third Friday is 14 days after first Friday
    third_friday = first_friday + timedelta(days=14)
    
    return third_friday
```

---

### 2. **`backtest_options_signals()` - No expiration monitoring during backtest**

**Location:** Lines 855-1080

**Problem:** The function checks for stop-loss, take-profit, and signal reversals, but it only closes positions at expiration *after* the signal loop ends. This means positions can be held past expiration during the backtest loop.

**Fix:** Add expiration check inside the position monitoring loop:
```python
# Inside the for pos in open_positions loop, add this check:

# Check if option is expiring soon (close 2 days before expiration)
try:
    exp_date = datetime.strptime(pos.expiration_date, '%Y-%m-%d')
    days_to_exp = (exp_date - current_date).days
    
    if days_to_exp <= 2:
        if verbose:
            print(f"[{current_date.strftime('%Y-%m-%d')}] EXPIRATION: {pos.option_type.upper()} "
                  f"${pos.strike_price} exp {pos.expiration_date}")
            print(f"  Entry: ${pos.entry_price:.2f} → Exit: ${current_option_price:.2f} "
                  f"({pnl_percent:.1f}%)")

        pos.exit_date = current_date
        pos.exit_index = signal.index
        pos.exit_price = current_option_price
        pos.exit_stock_price = current_price
        pos.exit_reason = 'expiration'
        pos.pnl_percent = pnl_percent
        pos.pnl_dollar = (current_option_price - pos.entry_price) * 100 * contracts_per_trade
        pos.days_held = (current_date - pos.entry_date).days

        positions_to_close.append(pos)
        capital += current_option_price * 100 * contracts_per_trade
        continue  # Skip other exit checks
except:
    pass
```

---

### 3. **`detect_overbought_oversold()` - Signal detection is backwards**

**Location:** Lines 267-299

**Problem:** The current logic triggers signals when the detrended value *crosses* the threshold, but this can miss the actual peak/trough. The signal fires when entering the zone, not when leaving it (which would be the actual reversal point).

**Current behavior:**
- Buy signal: When detrended crosses *below* oversold threshold (entering oversold)
- Sell signal: When detrended crosses *above* overbought threshold (entering overbought)

**Better approach:** Signal when *leaving* the zone (actual reversal):
```python
def detect_overbought_oversold(analysis: FourierAnalysis,
                                overbought_threshold: float,
                                oversold_threshold: float,
                                signal_on_exit: bool = True) -> List[SignalPoint]:
    """
    Detect buy/sell signals based on overbought/oversold thresholds.

    Parameters:
    -----------
    signal_on_exit : bool
        If True, signal when leaving the zone (reversal confirmed).
        If False, signal when entering the zone (early entry).
    """
    signals = []
    detrended = analysis.detrended_fourier

    for i in range(1, len(detrended)):
        if signal_on_exit:
            # Signal on EXIT from oversold zone (buy when recovering)
            if detrended[i-1] <= oversold_threshold and detrended[i] > oversold_threshold:
                signals.append(SignalPoint(
                    date=analysis.dates[i],
                    index=i,
                    price=analysis.prices[i],
                    fourier_value=analysis.fourier_prices[i],
                    detrended_value=detrended[i],
                    signal_type='buy',
                    reason='oversold_exit'
                ))

            # Signal on EXIT from overbought zone (sell when declining)
            elif detrended[i-1] >= overbought_threshold and detrended[i] < overbought_threshold:
                signals.append(SignalPoint(
                    date=analysis.dates[i],
                    index=i,
                    price=analysis.prices[i],
                    fourier_value=analysis.fourier_prices[i],
                    detrended_value=detrended[i],
                    signal_type='sell',
                    reason='overbought_exit'
                ))
        else:
            # Original behavior: signal on ENTRY
            if detrended[i-1] > oversold_threshold and detrended[i] <= oversold_threshold:
                signals.append(SignalPoint(
                    date=analysis.dates[i],
                    index=i,
                    price=analysis.prices[i],
                    fourier_value=analysis.fourier_prices[i],
                    detrended_value=detrended[i],
                    signal_type='buy',
                    reason='oversold'
                ))

            elif detrended[i-1] < overbought_threshold and detrended[i] >= overbought_threshold:
                signals.append(SignalPoint(
                    date=analysis.dates[i],
                    index=i,
                    price=analysis.prices[i],
                    fourier_value=analysis.fourier_prices[i],
                    detrended_value=detrended[i],
                    signal_type='sell',
                    reason='overbought'
                ))

    return signals
```

---

## Medium Priority Issues

### 4. **No trend filter to avoid counter-trend trades**

**Location:** `backtest_options_signals()` and `run_fourier_options_backtest()`

**Problem:** The model buys puts in a strong uptrend and calls in a strong downtrend, leading to many stop-losses.

**Fix:** Add trend filtering:
```python
def get_trend_direction(prices: np.ndarray, lookback: int = 20) -> str:
    """Determine overall trend using simple moving average slope."""
    if len(prices) < lookback:
        return 'neutral'
    
    recent = prices[-lookback:]
    slope = (recent[-1] - recent[0]) / recent[0] * 100  # Percentage change
    
    if slope > 5:  # 5% gain over lookback period
        return 'bullish'
    elif slope < -5:  # 5% loss over lookback period
        return 'bearish'
    return 'neutral'


def filter_signals_by_trend(signals: List[SignalPoint], 
                            prices: np.ndarray,
                            filter_mode: str = 'with_trend') -> List[SignalPoint]:
    """
    Filter signals based on trend.
    
    filter_mode:
        'with_trend': Only allow calls in uptrend, puts in downtrend
        'counter_trend': Only allow calls in downtrend, puts in uptrend (mean reversion)
        'none': No filtering
    """
    if filter_mode == 'none':
        return signals
    
    filtered = []
    for signal in signals:
        trend = get_trend_direction(prices[:signal.index+1])
        
        if filter_mode == 'with_trend':
            # Only take signals that align with trend
            if signal.signal_type == 'buy' and trend != 'bearish':
                filtered.append(signal)
            elif signal.signal_type == 'sell' and trend != 'bullish':
                filtered.append(signal)
        elif filter_mode == 'counter_trend':
            # Only take mean-reversion signals
            if signal.signal_type == 'buy' and trend == 'bearish':
                filtered.append(signal)
            elif signal.signal_type == 'sell' and trend == 'bullish':
                filtered.append(signal)
    
    return filtered
```

---

### 5. **Position sizing doesn't account for capital**

**Location:** `backtest_options_signals()` line ~970

**Problem:** Uses fixed `contracts_per_trade` regardless of capital or option price, leading to either oversized positions or insufficient capital errors.

**Fix:**
```python
def calculate_contracts(capital: float, option_price: float, 
                        max_risk_percent: float = 10.0,
                        min_contracts: int = 1,
                        max_contracts: int = 10) -> int:
    """
    Calculate optimal number of contracts based on available capital.
    
    Parameters:
    -----------
    capital : float
        Available capital
    option_price : float
        Price per share (will be multiplied by 100 for contract)
    max_risk_percent : float
        Maximum percentage of capital to risk per trade
    min_contracts : int
        Minimum contracts (0 if can't afford)
    max_contracts : int
        Maximum contracts regardless of capital
    
    Returns:
    --------
    int : Number of contracts to buy
    """
    cost_per_contract = option_price * 100
    max_capital_to_use = capital * (max_risk_percent / 100)
    
    if cost_per_contract > capital:
        return 0  # Can't afford even one contract
    
    affordable_contracts = int(max_capital_to_use // cost_per_contract)
    
    return max(min_contracts if affordable_contracts > 0 else 0, 
               min(affordable_contracts, max_contracts))
```

---

### 6. **Missing validation in `get_option_strike_price()`**

**Location:** Lines 694-739

**Problem:** The function can return strikes that don't exist in the options chain (e.g., $123.50 strike for a stock that only has $5 increments).

**Fix:** Add validation for realistic strike availability:
```python
def get_option_strike_price(stock_price: float, option_type: str,
                            otm_percent: float = 2.0,
                            available_strikes: List[float] = None) -> float:
    """
    Calculate an appropriate strike price for an option.
    
    Parameters:
    -----------
    available_strikes : List[float], optional
        If provided, will select the closest available strike
    """
    if option_type == 'call':
        strike = stock_price * (1 + otm_percent / 100)
    else:
        strike = stock_price * (1 - otm_percent / 100)

    # Determine rounding increment based on stock price
    if stock_price < 25:
        increment = 0.50
    elif stock_price < 200:
        increment = 1.00
    elif stock_price < 500:
        increment = 2.50
    else:
        increment = 5.00

    rounded_strike = round(strike / increment) * increment

    # If available strikes provided, find closest
    if available_strikes:
        closest = min(available_strikes, key=lambda x: abs(x - rounded_strike))
        return closest

    return rounded_strike
```

---

### 7. **`backtest_signals()` (stock backtest) has look-ahead bias**

**Location:** Lines 351-407

**Problem:** The stock backtesting function uses the final signal price for calculating final portfolio value, but the signal list might not include the last trading day.

**Fix:**
```python
def backtest_signals(signals: List[SignalPoint],
                     prices: np.ndarray,  # Add prices array
                     initial_capital: float = 10000.0,
                     shares_per_trade: Optional[int] = None) -> Dict:
    # ... existing code ...
    
    # Calculate final portfolio value using LAST KNOWN PRICE, not last signal
    final_price = prices[-1] if len(prices) > 0 else (signals[-1].price if signals else 0)
    final_value = capital + (shares * final_price)
    
    # ... rest of function
```

---

### 8. **No commission/slippage modeling**

**Location:** `backtest_options_signals()`

**Problem:** Real trading has costs that can significantly impact returns, especially for frequent trading.

**Fix:**
```python
def backtest_options_signals(ticker: str,
                             signals: List[SignalPoint],
                             analysis: FourierAnalysis,
                             # ... existing params ...
                             commission_per_contract: float = 0.65,  # Typical options commission
                             slippage_percent: float = 1.0,  # 1% slippage on entry/exit
                             verbose: bool = True) -> OptionsBacktestResults:
    
    # ... in the order execution code ...
    
    # Apply slippage to entry price
    if option_type == 'call' or option_type == 'put':
        # Buy orders: pay slightly more due to slippage
        entry_option_price = entry_option_price * (1 + slippage_percent / 100)
    
    # Calculate cost with commission
    cost = (entry_option_price * 100 * contracts_per_trade) + (commission_per_contract * contracts_per_trade)
    
    # ... when closing positions ...
    
    # Sell orders: receive slightly less due to slippage
    exit_price_after_slippage = current_option_price * (1 - slippage_percent / 100)
    revenue = (exit_price_after_slippage * 100 * contracts_per_trade) - (commission_per_contract * contracts_per_trade)
    capital += revenue
```

---

### 9. **`run_fourier_options_backtest()` missing key metrics**

**Location:** Lines 1182-1268

**Problem:** The function doesn't calculate important metrics like Sharpe ratio, max drawdown, profit factor, etc.

**Fix:** Add comprehensive metrics:
```python
def calculate_advanced_metrics(results: dict) -> dict:
    """Calculate advanced performance metrics."""
    trades = results['trades']
    capital_history = results['capital_history']
    
    if not trades:
        return {
            'sharpe_ratio': 0,
            'max_drawdown_percent': 0,
            'profit_factor': 0,
            'avg_winner': 0,
            'avg_loser': 0,
            'largest_winner': 0,
            'largest_loser': 0,
            'consecutive_wins': 0,
            'consecutive_losses': 0,
            'expectancy': 0
        }
    
    # Separate winners and losers
    winners = [t['pnl_dollar'] for t in trades if t['pnl_dollar'] and t['pnl_dollar'] > 0]
    losers = [t['pnl_dollar'] for t in trades if t['pnl_dollar'] and t['pnl_dollar'] <= 0]
    
    # Basic stats
    avg_winner = np.mean(winners) if winners else 0
    avg_loser = np.mean(losers) if losers else 0
    largest_winner = max(winners) if winners else 0
    largest_loser = min(losers) if losers else 0
    
    # Profit factor
    gross_profit = sum(winners) if winners else 0
    gross_loss = abs(sum(losers)) if losers else 1  # Avoid division by zero
    profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
    
    # Max drawdown
    equity_curve = [h['capital'] for h in capital_history]
    if equity_curve:
        peak = equity_curve[0]
        max_dd = 0
        for val in equity_curve:
            peak = max(peak, val)
            dd = (peak - val) / peak * 100
            max_dd = max(max_dd, dd)
    else:
        max_dd = 0
    
    # Consecutive wins/losses
    max_consec_wins = 0
    max_consec_losses = 0
    current_streak = 0
    last_was_win = None
    
    for t in trades:
        if t['pnl_dollar'] and t['pnl_dollar'] > 0:
            if last_was_win:
                current_streak += 1
            else:
                current_streak = 1
            last_was_win = True
            max_consec_wins = max(max_consec_wins, current_streak)
        else:
            if not last_was_win and last_was_win is not None:
                current_streak += 1
            else:
                current_streak = 1
            last_was_win = False
            max_consec_losses = max(max_consec_losses, current_streak)
    
    # Expectancy (expected value per trade)
    win_rate = len(winners) / len(trades) if trades else 0
    loss_rate = 1 - win_rate
    expectancy = (win_rate * avg_winner) + (loss_rate * avg_loser)
    
    # Sharpe ratio (simplified - using trade returns)
    returns = [t['pnl_percent'] for t in trades if t['pnl_percent'] is not None]
    if returns and np.std(returns) > 0:
        sharpe = np.mean(returns) / np.std(returns) * np.sqrt(252 / np.mean([t['days_held'] or 1 for t in trades]))
    else:
        sharpe = 0
    
    return {
        'sharpe_ratio': sharpe,
        'max_drawdown_percent': max_dd,
        'profit_factor': profit_factor,
        'avg_winner': avg_winner,
        'avg_loser': avg_loser,
        'largest_winner': largest_winner,
        'largest_loser': largest_loser,
        'consecutive_wins': max_consec_wins,
        'consecutive_losses': max_consec_losses,
        'expectancy': expectancy,
        'gross_profit': gross_profit,
        'gross_loss': gross_loss
    }
```

---

### 10. **Signal cooldown to prevent overtrading**

**Location:** `backtest_options_signals()`

**Problem:** Signals can cluster together, causing multiple positions to open on consecutive days.

**Fix:**
```python
def backtest_options_signals(ticker: str,
                             signals: List[SignalPoint],
                             # ... existing params ...
                             min_days_between_trades: int = 3,  # New parameter
                             verbose: bool = True) -> OptionsBacktestResults:
    
    # ... in the signal processing loop ...
    
    last_trade_date = None
    
    # Check if enough time has passed since last trade
    if last_trade_date is not None:
        days_since_last = (current_date - last_trade_date).days
        if days_since_last < min_days_between_trades:
            if verbose:
                print(f"[{current_date.strftime('%Y-%m-%d')}] SKIPPED: Cooldown period "
                      f"({days_since_last}/{min_days_between_trades} days)")
            continue
    
    # ... after successfully opening a position ...
    last_trade_date = current_date
```

---

## Summary Table

| # | Issue | Severity | Location |
|---|-------|----------|----------|
| 1 | Expiration dates wrong | **Critical** | `get_option_expiration()` |
| 2 | No expiration monitoring in loop | **Critical** | `backtest_options_signals()` |
| 3 | Signal detection direction | **High** | `detect_overbought_oversold()` |
| 4 | No trend filtering | **High** | New function needed |
| 5 | Fixed position sizing | **High** | `backtest_options_signals()` |
| 6 | Strike price validation | **Medium** | `get_option_strike_price()` |
| 7 | Look-ahead bias in stock backtest | **Medium** | `backtest_signals()` |
| 8 | No commission/slippage | **Medium** | `backtest_options_signals()` |
| 9 | Missing performance metrics | **Medium** | `run_fourier_options_backtest()` |
| 10 | No trade cooldown | **Low** | `backtest_options_signals()` |

---

Fix all these issues in @fourier.py.